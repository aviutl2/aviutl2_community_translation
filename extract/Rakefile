task default: %i[
       clean
       prepare
       build_plugin
       download_aviutl2
       download_innounp
       extract_locale
       extract_effects
       list_effects
       update_source
       update_aul2
     ]

task :clean do
  rm_rf "tmp"
  puts "Cleaned up temporary files."
end
task :prepare do
  mkdir_p "tmp"
  File.write("tmp/.gitignore", "*\n")
  puts "Prepared temporary directory."
end

task :build_plugin do
  sh "cmake -S . -B build -D CMAKE_BUILD_TYPE=Release", chdir: "./plugin"
  sh "cmake --build build --config Release", chdir: "./plugin"
end

task :download_innounp do
  if File.exist?("tmp/innounp/innounp.exe")
    puts "innounp.exe already exists."
    next
  end

  require "open-uri"
  require "zip"

  innounp_url = "https://www.rathlev-home.de/tools/download/innounp-2.zip"
  innounp_zip_path = "tmp/innounp.zip"
  puts "Downloading innounp from #{innounp_url}..."
  URI.open(innounp_url) do |remote_file|
    File.open(innounp_zip_path, "wb") { |file| file.write(remote_file.read) }
  end
  puts "Downloaded innounp to #{innounp_zip_path}."

  Zip::File.open(innounp_zip_path) do |zip_file|
    zip_file.each do |entry|
      dest_path = File.join("tmp", "innounp", entry.name)
      mkdir_p File.dirname(dest_path) unless Dir.exist?(File.dirname(dest_path))
      zip_file.extract(entry, dest_path) unless File.exist?(dest_path)
    end
  end
end

task :download_aviutl2 do
  require "open-uri"
  require "zip"

  html_url = "https://spring-fragrance.mints.ne.jp/aviutl/"
  html_content = URI.open(html_url).read
  zip_filename = html_content.match(/<A HREF="(aviutl2beta[0-9a-z]+\.zip)">/)[1]
  zip_url = html_url + zip_filename
  zip_path = "tmp/aviutl2.zip"
  puts "Downloading #{zip_url}..."
  URI.open(zip_url) do |remote_file|
    File.open(zip_path, "wb") { |file| file.write(remote_file.read) }
  end
  puts "Downloaded to #{zip_path}."

  installer_path = "tmp/aviutl2_setup.exe"
  installer_filename =
    html_content.match(/<A HREF="(AviUtl2beta[0-9a-z]+_setup\.exe)">/)[1]
  installer_url = html_url + installer_filename
  puts "Downloading installer #{installer_url}..."
  URI.open(installer_url) do |remote_file|
    File.open(installer_path, "wb") { |file| file.write(remote_file.read) }
  end
  puts "Downloaded installer to #{installer_path}."

  Zip::File.open(zip_path) do |zip_file|
    zip_file.each do |entry|
      dest_path = File.join("tmp", "aviutl2", entry.name)
      mkdir_p File.dirname(dest_path) unless Dir.exist?(File.dirname(dest_path))
      zip_file.extract(entry, dest_path) unless File.exist?(dest_path)
    end
  end
  puts "Extracted ZIP to tmp/aviutl2."
end

task :extract_locale do
  require "open3"
  require "fileutils"

  puts "Extracting locale data..."
  puts "Running AviUtl2 installer to extract locale data..."
  rm_rf "./tmp/installer_decompressed"
  sh "./tmp/innounp/innounp.exe -x -d./tmp/installer_decompressed ./tmp/aviutl2_setup.exe"
  locale_source =
    "./tmp/installer_decompressed/{commonappdata}/aviutl2/Language/English.aul2"
  locale_dest = "../locales/original_english.aul2"
  cp locale_source, locale_dest
end

task :extract_effects do
  require "open3"
  puts "Extracting effects..."

  rm_rf "./tmp/aviutl2/data"
  mkdir_p "./tmp/aviutl2/data/Plugin"
  cp "./plugin/build/Release/ExtractPlugin.dll",
     "./tmp/aviutl2/data/Plugin/ExtractPlugin.aux2"
  mkdir_p "./tmp/aviutl2/data/extract"

  mode_path = "./tmp/aviutl2/data/extract/mode.txt"
  File.write(mode_path, "extract")

  puts "Trusting ExtractPlugin.aux2 for effect extraction."
  File.write("./tmp/aviutl2/data/module.ini", <<~INI)
    [ExtractPlugin.aux2]
    trust=1
  INI
  puts "Launching AviUtl2 to extract effects..."

  current_time = Time.now
  spawn("tmp/aviutl2/AviUtl2.exe")
  while Time.now - current_time < 60
    sleep 1
    unless File.exist?(mode_path)
      puts "Effect extraction completed."
      break
    end
  end

  rm_rf "./tmp/extracted_effects"
  cp_r "./tmp/aviutl2/data/extract/effects", "./tmp/extracted_effects"
end

task :list_effects do
  require "json"
  require "inifile"
  puts "Listing extracted effects..."
  effects_dir = "./tmp/extracted_effects"
  common_effects = {}
  effects = {}
  Dir
    .glob("#{effects_dir}/*.object")
    .each do |path|
      ini = IniFile.load(path)
      object_0 = ini["Object.0"].to_h
      effect_name = object_0.delete("effect.name")
      object_0.delete("Group") # TODO: なにこれ
      effects[effect_name] = object_0.keys

      object_1 = ini["Object.1"]
      unless object_1.empty?
        effect_name_1 = object_1.delete("effect.name")
        object_1.delete("Group") # TODO: なにこれ
        effects[effect_name_1] = object_1.keys
      end
    end

  File.write(
    "./effects.json",
    JSON.pretty_generate({ **common_effects, **effects })
  )
  puts "Wrote effects list to ./tmp/effects.json."
end

languages = %i[ja en de]
TRANSLATE_PLACEHOLDER = "(translate here)"

task :update_source do
  require "inifile"
  require "yaml"
  require "json"

  languages.each do |lang|
    unless Dir.exist?("../translations/#{lang}")
      mkdir_p "../translations/#{lang}"
    end
  end

  puts "Updating translation source..."

  main_translations = IniFile.load("../locales/original_english.aul2")
  effects = JSON.parse(File.read("./effects.json"))
  effect_keys = effects.keys.to_set
  languages.each do |lang|
    editor_file_path = "../translations/#{lang}/editor.yml"
    current_translations =
      (
        File.exist?(editor_file_path) ? YAML.load_file(editor_file_path) : {}
      ).to_h
    translations = {}
    main_translations.each_section do |section|
      translations[section] = {}
      main_translations[section].each do |key, value|
        translate_in_effect = section == "Effect" && effect_keys.include?(key)
        if translate_in_effect
          next
        elsif lang == :ja
          translations[section][key] = key
        elsif is_translated?(current_translations.dig(section, key))
          translations[section][key] = current_translations.dig(section, key)
        else
          translations[section][key] = nil
        end
      end
    end
    File.open(editor_file_path, "w") do |file|
      translations.each do |section_name, section_content|
        file.puts "#{section_name}:"
        section_content.each do |key, value|
          main_translations[section_name][key].lines.each do |line|
            file.puts "  # #{line.chomp}".rstrip
          end
          file.puts "  '#{key}': |"
          if value.nil?
            file.puts "    #{TRANSLATE_PLACEHOLDER}"
          else
            value.lines.each { |line| file.puts "    #{line.chomp}".rstrip }
          end
          file.puts
        end
      end
    end

    puts "Updated translation source for #{lang} at #{editor_file_path}."

    effect_file_path = "../translations/#{lang}/effects.yml"
    current_effect_translations =
      (
        File.exist?(effect_file_path) ? YAML.load_file(effect_file_path) : {}
      ).to_h
    effect_translations = {}
    effects.each do |effect_name, keys|
      effect_translations[effect_name] = { effect_name => nil }
      if lang == :ja
        effect_translations[effect_name][effect_name] = effect_name
      elsif is_translated?(
            current_effect_translations.dig(effect_name, effect_name)
          )
        effect_translations[effect_name][
          effect_name
        ] = current_effect_translations.dig(effect_name, effect_name)
      end
      keys.each do |key|
        if lang == :ja
          effect_translations[effect_name][key] = key
        elsif is_translated?(current_effect_translations.dig(effect_name, key))
          effect_translations[effect_name][
            key
          ] = current_effect_translations.dig(effect_name, key)
        else
          effect_translations[effect_name][key] = nil
        end
      end
    end

    File.open(effect_file_path, "w") do |file|
      effect_translations.each do |effect_name, section_content|
        file.puts "'#{effect_name}':"
        section_content.each do |key, value|
          if main_translations["Effect"].key?(key)
            main_translations["Effect"][key].lines.each do |line|
              file.puts "  # #{line.chomp}".rstrip
            end
          else
            file.puts "  # (No default text available)"
          end
          file.puts "  '#{key}': |"
          if value.nil?
            file.puts "    #{TRANSLATE_PLACEHOLDER}"
          else
            value.lines.each { |line| file.puts "    #{line.chomp}" }
          end
          file.puts
        end
      end
    end
    puts "Updated effect translation source for #{lang} at #{effect_file_path}."
  end
end

task :update_aul2 do
  require "yaml"
  require "inifile"

  main_translations = IniFile.load("../locales/original_english.aul2")
  languages.each do |lang|
    puts "Building localized .aul2 for #{lang}..."
    editor_file_path = "../translations/#{lang}/editor.yml"
    effect_file_path = "../translations/#{lang}/effects.yml"
    editor_translations = YAML.load_file(editor_file_path).to_h
    effect_translations = YAML.load_file(effect_file_path).to_h

    sections = {}
    num_translated = 0
    num_total = 0
    main_translations.each_section do |section|
      sections[section] = {}
      main_translations[section].each do |key, value|
        translated_value = editor_translations.dig(section, key)
        if section == "Effect" && effect_translations.dig(key, key)
          translated_value = effect_translations.dig(key, key)
        end
        num_total += 1
        if is_translated?(translated_value&.chomp)
          num_translated += 1
          sections[section][key] = translated_value.chomp
        else
          sections[section][key] = value
        end
      end
    end
    effect_translations.each do |effect_name, effect_params|
      sections[effect_name] ||= {}
      effect_params.each do |key, translated_value|
        num_total += 1
        if is_translated?(translated_value&.chomp)
          num_translated += 1
          sections[effect_name][key] = translated_value.chomp
        end
      end
    end
    output_path = "../locales/community_#{lang}.aul2"
    File.open(output_path, "w") do |file|
      file.puts "; AviUtl2 Community Translation (#{lang})"
      file.puts "; Generated automatically. Do not edit directly."
      file.puts "; Translated #{num_translated} of #{num_total} entries (#{
                  (num_translated.to_f / num_total * 100).round(2)
                }%)."
      file.puts "; Source:"
      file.puts ";   https://github.com/aviutl2/aviutl2_community_translation"
      file.puts
      sections.each do |section_name, section_content|
        next if section_content.empty?
        file.puts "[#{section_name}]"
        section_content.each do |key, value|
          escaped_value = value.gsub("\n", "\\n")
          file.puts "#{key}=#{escaped_value}"
        end
        file.puts
      end
    end
    puts "Wrote localized .aul2 to #{output_path}."
    puts "Translation progress: #{num_translated}/#{num_total} (#{
           (num_translated.to_f / num_total * 100).round(2)
         }%)."
  end
end

def is_translated?(text)
  return false if text.nil?

  stripped = text.strip
  return false if stripped.empty?
  return false if stripped == TRANSLATE_PLACEHOLDER

  true
end

namespace :crowdin do
  task :list_projects do
    require "crowdin-api"
    require "dotenv/load"

    client =
      Crowdin::Client.new { |config| config.api_token = ENV["CROWDIN_TOKEN"] }
    projects = client.list_projects

    projects["data"].each do |project|
      puts "Project ID: #{project["data"]["id"]}, Name: #{project["data"]["name"]}"
    end
  end

  task :upload_source do
    require "crowdin-api"
    require "dotenv/load"

    crowdin =
      Crowdin::Client.new do |config|
        config.api_token = ENV["CROWDIN_TOKEN"]
        config.project_id = ENV["CROWDIN_PROJECT_ID"]
      end

    editor_file_path = "../translations/ja/editor.yml"
    effect_file_path = "../translations/ja/effects.yml"

    files = crowdin.list_files
    [editor_file_path, effect_file_path].each do |path|
      puts "Uploading #{path} to Crowdin..."
      storage_id = crowdin.add_storage(File.open(path, "r"))["data"]["id"]
      existing_file_id =
        files["data"]
          .find { |f| f["data"]["name"] == File.basename(path).to_s }
          &.dig("data", "id")

      if existing_file_id
        response =
          crowdin.update_or_restore_file(
            existing_file_id,
            storageId: storage_id
          )
        raise "Failed to update file on Crowdin" unless response["data"]
        puts "Updated #{path} on Crowdin."
      else
        response =
          crowdin.add_file(storageId: storage_id, name: File.basename(path))
        raise "Failed to add file to Crowdin" unless response["data"]
        puts "Added #{path} as a new file on Crowdin."
      end
    end
  end
  task :download_translations do
    require "crowdin-api"
    require "open-uri"
    require "zip"
    require "dotenv/load"

    crowdin =
      Crowdin::Client.new do |config|
        config.api_token = ENV["CROWDIN_TOKEN"]
        config.project_id = ENV["CROWDIN_PROJECT_ID"]
      end

    puts "Downloading translations from Crowdin..."
    build_id = crowdin.build_project_translation["data"]["id"]
    status_response = nil
    loop do
      status_response = crowdin.check_project_build_status(build_id)
      if status_response["data"]["status"] == "finished"
        break
      else
        puts "Translation build status: #{status_response["data"]["status"]}. Waiting..."
        sleep 5
      end
    end
    download_url =
      crowdin.download_project_translations(build_id)["data"]["url"]
    zip_path = "tmp/crowdin_translations.zip"
    URI.open(download_url) do |remote_file|
      File.open(zip_path, "wb") { |file| file.write(remote_file.read) }
    end

    Dir.chdir("..") do
      Zip::File.open("./extract/" + zip_path) do |zip_file|
        zip_file.each do |entry|
          next if entry.name.end_with?("/")
          dest_path = File.join(".", "translations", entry.name)
          unless Dir.exist?(File.dirname(dest_path))
            mkdir_p File.dirname(dest_path)
          end
          puts "Extracting #{entry.name} to #{dest_path}..."
          rm dest_path if File.exist?(dest_path)
          zip_file.extract(entry, dest_path)
        end
      end
    end
  end

  task sync: %i[upload_source download_translations]
end
